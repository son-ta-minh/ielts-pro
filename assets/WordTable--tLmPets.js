import{r as t,$ as we,_ as Dt,ag as ge,a7 as De,j as m,aA as ye,ay as Se,av as Te,aB as Pe,aC as Pt,aD as _t,aE as Nt,a6 as _e,aF as k,aa as $t,aq as jt,ab as Y,aG as Ut,a4 as Ht,t as zt}from"./index-do2UTbG5.js";import{D as Ne,W as Gt,U as $e}from"./WordTable_UI-Djq41Nsw.js";function Jt(p){const h=p.map(b=>{const W={word:b.word},M=(b.collocationsArray||[]).filter(A=>!A.d).map(A=>A.text),F=(b.idiomsList||[]).filter(A=>!A.d).map(A=>A.text);return M.length>0&&(W.collocations=M),F.length>0&&(W.idioms=F),W}).filter(b=>b.collocations||b.idioms);return`You are an expert IELTS coach. Your task is to provide descriptive hints for collocations and idioms.

    TASK:
    Analyze the following JSON array. For each word, there is a list of its collocations and/or idioms that are missing a descriptive hint ("d").
    For EACH collocation and idiom string, you MUST generate a minimal descriptive cue that helps recall it. This cue should be 5-10 words.
    
    INPUT DATA:
    ${JSON.stringify(h,null,2)}

    INSTRUCTIONS:
    1.  Read the input data.
    2.  For each word, process its 'collocations' and/or 'idioms' lists.
    3.  Return a new JSON array. Each object in the array must contain:
        - "og": The original word.
        - "col": (if present in input) An array of objects, where each object has "text" (the original collocation) and "d" (your new descriptive hint).
        - "idm": (if present in input) An array of objects, where each object has "text" (the original idiom) and "d" (your new descriptive hint).
    4.  Do NOT modify the "text" of the items. Do NOT add any items that were not in the input.

    Return in code block format STRICT JSON OUTPUT FORMAT:
    [
      {
        "og": "original_word_1",
        "col": [
          { "text": "collocation_string_1", "d": "your new descriptive hint for it" }
        ],
        "idm": [
          { "text": "idiom_string_1", "d": "your new hint for this idiom" }
        ]
      },
      {
        "og": "original_word_2",
        "col": [
          { "text": "collocation_string_3", "d": "a hint for this collocation" }
        ]
      }
    ]
    `}function Vt(p){return`You are an expert IELTS coach, examiner, and native English speaker.
    
    TASK: Analyze this list of vocabulary items: [${p.map(z=>`"${z.word}"`).join(", ")}].

    For EACH item, generate a controlled paraphrase system (max 5 items total). 
    
    RULES:
    - Do NOT generate 'para' (paraphrase) for orthographic variants (e.g., space vs no space, hyphen vs no hyphen).
    - ONLY generate categories if a natural equivalent exists. 
    - Try to force all tone types but avoid unnatural versions.
    - Each item MUST be an object: {"w": "word_or_phrase", "t": "tone_type", "c": "recall cue"}.
    - 't' (tone) MUST be one of: "academic", "casual", "synonym" (no hypernyms or hyponyms)
    - 'c' (context) = a short (2-5 words) situational recall cue (e.g., "job interview", "arguing with friend").

    STRICT JSON OUTPUT FORMAT:
    Return in code block format a single JSON array of objects in codeblock. Each object represents one word from the input list.
    
    [
      {
        "og": "string (the EXACT original word from the input list)",
        "para": [
          {
            "w": "string",
            "t": "string",
            "c": "string"
          }
        ]
      }
    ]
    `}const je="vocab_pro_library_filters_v2",Ue=["vocab","idiom","phrasal","collocation","phrase"],He=["archive"],Kt=({user:p,words:h,total:z,loading:b,page:W,pageSize:M,onPageChange:F,onPageSizeChange:A,onSearch:ze,onFilterChange:Ge,onAddWords:Je,onViewWord:Ve,onEditWord:qe,onDelete:Q,onHardDelete:Ye,onBulkDelete:G,onBulkHardDelete:J,onPractice:Qe,settingsKey:V,context:w,initialFilter:L,forceExpandAdd:Ae,onExpandAddConsumed:K,onWordRenamed:Ie,showTagBrowserButton:Ke,tagTree:Xe,selectedTag:Ze,onSelectTag:et,onOpenWordBook:tt})=>{const g=t.useMemo(()=>we(je,{}),[]),{showToast:qt}=Dt(),[C,st]=t.useState(g.query||""),[x,X]=t.useState(()=>Array.isArray(g.activeFilters)?new Set(g.activeFilters):new Set(["all"])),[B,Z]=t.useState(g.refinedFilter||"all"),[D,ot]=t.useState(g.statusFilter||"all"),[P,nt]=t.useState(g.registerFilter||"all"),[_,at]=t.useState(g.sourceFilter||"all"),[N,it]=t.useState(g.compositionFilter||"all"),[$,rt]=t.useState(g.bookFilter||"all"),[j,lt]=t.useState(g.specificBookId||""),[dt,ee]=t.useState(!1),[te,be]=t.useState(g.isFilterMenuOpen||!1),[se,ve]=t.useState(""),[ct,Re]=t.useState(!1),[ut,We]=t.useState(!1),Oe=t.useRef(!0);t.useEffect(()=>{ge(je,{query:C,activeFilters:Array.from(x),refinedFilter:B,statusFilter:D,registerFilter:P,sourceFilter:_,compositionFilter:N,bookFilter:$,specificBookId:j,isFilterMenuOpen:te,page:W,pageSize:M})},[C,x,B,D,P,_,N,$,j,te,W,M]);const[Me,ft]=t.useState(new Set(["vocab"])),[f,S]=t.useState(new Set),[y,oe]=t.useState(null),[ne,U]=t.useState(!1),[mt,pt]=t.useState(null),[Ee,ae]=t.useState(!1),[ht,ie]=t.useState(!1),[wt,re]=t.useState(!1),[le,de]=t.useState(!1),[ke,ce]=t.useState(!1),[Fe,ue]=t.useState(!1),[fe,u]=t.useState(null),[gt,q]=t.useState(!1),[Le,Ce]=t.useState([]),me=t.useRef(null),[pe,yt]=t.useState(()=>{const e=we(V,null);return e?{...Ne,...e}:Ne});t.useEffect(()=>{ge(V,pe)},[pe,V]),t.useEffect(()=>{const e=s=>{me.current&&!me.current.contains(s.target)&&We(!1)};return document.addEventListener("mousedown",e),()=>document.removeEventListener("mousedown",e)},[]),t.useEffect(()=>{L&&(["raw","refined","verified","failed","not_refined"].includes(L)?(Z(L),X(new Set(["all"]))):(X(new Set([L])),Z("all")),be(!0))},[L]),t.useEffect(()=>{Ae&&(ee(!0),K==null||K())},[Ae]),t.useEffect(()=>{const e=setTimeout(()=>ze(C),300);return()=>clearTimeout(e)},[C]),t.useEffect(()=>{Ge({types:x,refined:B,status:D,register:P,source:_,composition:N,book:$,specificBookId:j}),Oe.current?Oe.current=!1:(F(0),S(new Set))},[x,B,D,P,_,N,$,j]),t.useEffect(()=>{if(fe){const e=setTimeout(()=>u(null),4e3);return()=>clearTimeout(e)}},[fe]);const St=e=>{X(s=>{const o=new Set(s);return e==="all"?new Set(["all"]):(o.delete("all"),o.has(e)?o.delete(e):o.add(e),o.size===0?new Set(["all"]):o)})},Tt=e=>{ft(s=>{const o=new Set(s),a=(i,l)=>{l.forEach(r=>i.delete(r))};return Ue.includes(e)?o.has(e)?o.delete(e):(a(o,Ue),o.add(e)):He.includes(e)&&(o.has(e)?o.delete(e):(a(o,He),o.add(e))),o})},At=async()=>{if(se.trim()){Re(!0);try{await Je(se,Me),u({type:"success",message:"Words added successfully."}),ve(""),ee(!1)}catch{u({type:"error",message:"Failed to add words."})}finally{Re(!1)}}},T=t.useMemo(()=>h.filter(e=>f.has(e.id)),[h,f]),O=t.useMemo(()=>h.filter(e=>f.has(e.id)&&e.quality===De.RAW),[h,f]),H=t.useMemo(()=>h.filter(e=>f.has(e.id)&&(e.collocationsArray&&e.collocationsArray.some(s=>!s.d)||e.idiomsList&&e.idiomsList.some(s=>!s.d))),[h,f]),It=async()=>{if(!(!G||f.size===0)){U(!0);try{await G(f),u({type:"success",message:`${w==="unit"?"Unlinked":"Deleted"} ${f.size} item(s).`}),S(new Set)}catch{u({type:"error",message:"Failed to remove items."})}finally{U(!1),ie(!1)}}},bt=async()=>{if(!(!J||O.length===0)){ae(!0);try{const e=new Set(O.map(s=>s.id));await J(e),u({type:"success",message:`Permanently deleted ${e.size} raw item(s).`}),S(s=>{const o=new Set(s);return e.forEach(a=>o.delete(a)),o})}catch{u({type:"error",message:"Failed to delete items."})}finally{ae(!1),re(!1)}}},vt=async e=>{const o=zt().filter(a=>e.has(a.id)).map(a=>({...a,quality:De.VERIFIED,updatedAt:Date.now()}));o.length>0&&(await Y(o),u({type:"success",message:`Marked ${o.length} item(s) as Verified.`}),S(new Set))},Rt=()=>{const e=h.filter(l=>f.has(l.id));if(e.length===0)return;const s=we("vocab_pro_mimic_practice_queue",[]),o=new Set(s.map(l=>l.text.toLowerCase().trim()));let a=0;const i=[];if(e.forEach(l=>{const r=l.word;o.has(r.toLowerCase().trim())||(i.push({id:`pronun-${Date.now()}-${Math.random()}`,text:r,sourceWord:l.word,type:"Library Word"}),o.add(r.toLowerCase().trim()),a++)}),a>0){const l=[...s,...i];ge("vocab_pro_mimic_practice_queue",l),u({type:"success",message:`Added ${a} words to Pronunciation.`}),S(new Set)}else u({type:"info",message:"Selected words are already in Pronunciation queue."})},xe=async e=>{if(!Array.isArray(e))throw new Error("Response must be an array.");const s=new Map;e.forEach(r=>{var c;const n=(r.og||r.original||r.hw||r.headword||"").toLowerCase();n&&(s.has(n)||s.set(n,[]),(c=s.get(n))==null||c.push(r))});const o=new Map(T.map(r=>[r.word.toLowerCase(),r])),a=[],i=[],l=[];for(const[r,n]of o){const c=s.get(r);if(!c||c.length===0)continue;const d=c[0],v=Nt(d),I=(v.headword||v.word||"").trim();if(I){const xt=n.word.trim().split(/\s+/).length,Bt=I.trim().split(/\s+/).length;if(xt!==Bt){const he=await _e(n.userId,I);if(he){const R=k(he,d);a.push(R)}else{const R=$t(I,"","","","",[],!1,!1,!1,!1,!1,"refine");R.userId=n.userId;const E=k(R,d);a.push(E)}}else if(I.toLowerCase()!==n.word.toLowerCase()){const R=await _e(n.userId,I);if(R&&R.id!==n.id){const E=k(R,d);a.push(E),i.push(n.id),l.push({id:n.id,oldWord:n.word,newWord:I})}else{let E=k(n,d);E.word=I,a.push(E),l.push({id:n.id,oldWord:n.word,newWord:I})}}else a.push(k(n,d))}else a.push(k(n,d))}if(i.length>0&&await jt(i),a.length>0){await Y(a),l.length>0&&Ie&&Ie(l);let r=`Refined ${a.length} words.`;i.length>0?r+=` Merged ${i.length} duplicates.`:l.length>0&&(r+=` Renamed ${l.length} to base forms.`),u({type:"success",message:r}),S(new Set)}de(!1)},Wt=async e=>{var a;if(!Array.isArray(e))throw new Error("Response must be an array.");const s=new Map(T.map(i=>[i.word.toLowerCase(),i])),o=[];for(const i of e){const l=s.get((a=i.og)==null?void 0:a.toLowerCase());if(!l)continue;const r=(i.para||[]).map(n=>({word:n.w,tone:n.t,context:n.c,isIgnored:!1}));o.push({...l,paraphrases:r,updatedAt:Date.now()})}o.length>0&&(await Y(o),u({type:"success",message:`Refined paraphrases for ${o.length} words.`}),S(new Set)),ce(!1)},Be=e=>Ut(Ht(e.words),p.nativeLanguage||"Vietnamese"),Ot=e=>Vt(T),Mt=e=>Jt(H),Et=async e=>{var a;if(!Array.isArray(e)){u({type:"error",message:"Invalid response from AI."});return}const s=[],o=new Map(H.map(i=>[i.word.toLowerCase(),i]));for(const i of e){const l=o.get((a=i.og)==null?void 0:a.toLowerCase());if(!l)continue;let r=!1;const n={...l};if(i.col&&l.collocationsArray){const c=new Map(i.col.map(d=>[d.text.toLowerCase(),d.d]));n.collocationsArray=(n.collocationsArray||[]).map(d=>{if(!d.d){const v=c.get(d.text.toLowerCase());if(v)return r=!0,{...d,d:String(v)}}return d})}if(i.idm&&l.idiomsList){const c=new Map(i.idm.map(d=>[d.text.toLowerCase(),d.d]));n.idiomsList=(n.idiomsList||[]).map(d=>{if(!d.d){const v=c.get(d.text.toLowerCase());if(v)return r=!0,{...d,d:String(v)}}return d})}r&&(n.updatedAt=Date.now(),s.push(n))}s.length>0?(await Y(s),u({type:"success",message:`Added hints to ${s.length} word(s).`}),S(new Set)):u({type:"info",message:"No new hints were added."}),ue(!1)},kt=async()=>{const e=await Pe(p.id);Ce(e),q(!0)},Ft=async e=>{var n;const s=Le.find(c=>c.id===e);if(!s)return;const o=h.filter(c=>f.has(c.id)),a=new Set(s.words.map(c=>c.word.toLowerCase())),i=o.filter(c=>!a.has(c.word.toLowerCase())).map(c=>({word:c.word,definition:c.meaningVi}));if(i.length===0){u({type:"info",message:"All selected words are already in this book."}),q(!1);return}const l=[...s.words,...i].sort((c,d)=>c.word.toLowerCase().localeCompare(d.word.toLowerCase())),r={...s,words:l,updatedAt:Date.now()};await Pt(r),await _t(p.id),u({type:"success",message:`Added ${i.length} words to "${(n=s.topic.split(":").pop())==null?void 0:n.trim()}".`}),q(!1),S(new Set)};t.useEffect(()=>{(async()=>{const s=await Pe(p.id);Ce(s)})()},[p.id]);const Lt=async()=>{if(!(!Q||!y)){U(!0);try{await Q(y),u({type:"success",message:`Deleted "${y.word}".`}),oe(null)}catch{u({type:"error",message:"Failed to delete word."})}finally{U(!1)}}},Ct={words:h,total:z,loading:b,page:W,pageSize:M,onPageChange:F,onPageSizeChange:A,onPractice:Qe,context:w,onDelete:Q,onViewWord:Ve,onEditWord:qe,query:C,setQuery:st,activeFilters:x,refinedFilter:B,statusFilter:D,registerFilter:P,sourceFilter:_,compositionFilter:N,bookFilter:$,specificBookId:j,onSpecificBookChange:lt,isAddExpanded:dt,isFilterMenuOpen:te,quickAddInput:se,setQuickAddInput:ve,isAdding:ct,isViewMenuOpen:ut,selectedIds:f,setSelectedIds:S,wordToDelete:y,setWordToDelete:oe,isDeleting:ne,setIsDeleting:U,wordToHardDelete:mt,setWordToHardDelete:pt,isHardDeleting:Ee,setIsHardDeleting:ae,onHardDelete:Ye,isAiModalOpen:le,setIsAiModalOpen:de,notification:fe,viewMenuRef:me,visibility:pe,setVisibility:yt,handleToggleFilter:St,handleBatchAddSubmit:At,onOpenBulkDeleteModal:G?()=>ie(!0):void 0,onBulkVerify:vt,onOpenBulkHardDeleteModal:J&&O.length>0?()=>re(!0):void 0,selectedWordsToRefine:T,handleGenerateRefinePrompt:Be,handleAiRefinementResult:xe,selectedRawWordsCount:O.length,selectedWordsMissingHintsCount:H.length,onOpenHintModal:()=>ue(!0),setStatusFilter:ot,setRefinedFilter:Z,setRegisterFilter:nt,setSourceFilter:at,setCompositionFilter:it,setBookFilter:rt,setIsViewMenuOpen:We,setIsFilterMenuOpen:be,setIsAddExpanded:ee,settingsKey:V,showTagBrowserButton:Ke,tagTree:Xe,selectedTag:Ze,onSelectTag:et,selectedTypes:Me,toggleType:Tt,onOpenWordBook:tt,onOpenAddToBookModal:kt,isAddToBookModalOpen:gt,setIsAddToBookModalOpen:q,wordBooks:Le,onConfirmAddToBook:Ft,onAddToPronunciation:Rt,onOpenParaModal:()=>ce(!0)};return m.jsxs(m.Fragment,{children:[m.jsx(Gt,{...Ct}),m.jsx(ye,{isOpen:!!y,title:w==="unit"?"Unlink Word?":"Delete Word?",message:w==="unit"?`Remove "${y==null?void 0:y.word}" from this unit? It will remain in your library.`:`Permanently delete "${y==null?void 0:y.word}"? This action cannot be undone.`,confirmText:w==="unit"?"UNLINK":"DELETE",isProcessing:ne,onConfirm:Lt,onClose:()=>oe(null),confirmButtonClass:w==="unit"?"bg-orange-600 text-white hover:bg-orange-700 shadow-orange-200":"bg-red-600 text-white hover:bg-red-700 shadow-red-200",icon:w==="unit"?m.jsx($e,{size:40,className:"text-orange-50"}):m.jsx(Se,{size:40,className:"text-red-500"})}),G&&m.jsx(ye,{isOpen:ht,title:w==="unit"?`Unlink ${f.size} Words?`:`Delete ${f.size} Words?`,message:w==="unit"?`Remove ${f.size} selected words from this unit? They will remain in your library.`:`Permanently delete ${f.size} selected words? This action cannot be undone.`,confirmText:w==="unit"?`UNLINK ${f.size}`:`DELETE ${f.size}`,isProcessing:ne,onConfirm:It,onClose:()=>ie(!1),confirmButtonClass:w==="unit"?"bg-orange-600 text-white hover:bg-orange-700 shadow-orange-200":"bg-red-600 text-white hover:bg-red-700 shadow-red-200",icon:w==="unit"?m.jsx($e,{size:40,className:"text-orange-50"}):m.jsx(Se,{size:40,className:"text-red-500"})}),J&&m.jsx(ye,{isOpen:wt,title:`Delete ${O.length} Raw Words?`,message:`Permanently delete ${O.length} selected RAW words from your entire library? This action cannot be undone.`,confirmText:`DELETE ${O.length} RAW WORDS`,isProcessing:Ee,onConfirm:bt,onClose:()=>re(!1),confirmButtonClass:"bg-red-600 text-white hover:bg-red-700 shadow-red-200",icon:m.jsx(Se,{size:40,className:"text-red-500"})}),Fe&&H.length>0&&m.jsx(Te,{isOpen:Fe,onClose:()=>ue(!1),type:"REFINE_WORDS",title:"Refine Hints",description:`Generating hints for ${H.length} selected word(s).`,initialData:{},user:p,onGeneratePrompt:Mt,onJsonReceived:Et,actionLabel:"Apply Hints",hidePrimaryInput:!0}),le&&T.length>0&&m.jsx(Te,{isOpen:le,onClose:()=>de(!1),type:"REFINE_WORDS",title:"Refine Selected Words",description:`Generating details for ${T.length} selected word(s).`,initialData:{words:T.map(e=>e.word).join("; ")},user:p,onGeneratePrompt:Be,onJsonReceived:xe,actionLabel:"Apply to All"}),ke&&T.length>0&&m.jsx(Te,{isOpen:ke,onClose:()=>ce(!1),type:"REFINE_WORDS",title:"Refine Paraphrases",description:`Generating fresh paraphrases for ${T.length} selected word(s). This will OVERWRITE existing data.`,initialData:{words:T.map(e=>e.word).join("; ")},user:p,onGeneratePrompt:Ot,onJsonReceived:Wt,actionLabel:"Overwrite Paraphrases"})]})};export{Kt as W};
